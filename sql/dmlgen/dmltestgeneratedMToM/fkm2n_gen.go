// Code generated by corestoreio/pkg/util/codegen. DO NOT EDIT.
// Generated by sql/dmlgen. DO NOT EDIT.
package dmltestgeneratedMToM

import (
	"context"
	"time"

	"github.com/corestoreio/errors"
	"github.com/corestoreio/pkg/sql/ddl"
	"github.com/corestoreio/pkg/sql/dml"
	"github.com/corestoreio/pkg/storage/null"
)

type athleteRelations struct {
	parent             *Athlete
	AthleteTeamMembers *AthleteTeamMembers // Reversed 1:M athlete.athlete_id => athlete_team_member.athlete_id
	AthleteTeams       *AthleteTeams       // Reversed M:N athlete.athlete_id via athlete_team_member.athlete_id => athlete_team.team_id
}

func (e *Athlete) setRelationParent() {
	if e.Relations != nil && e.Relations.parent == nil {
		e.Relations.parent = e
	}
}

func (e *Athlete) NewRelations() *athleteRelations {
	e.Relations = &athleteRelations{parent: e}
	return e.Relations
}

// Athlete represents a single row for DB table athlete. Auto generated.
// Table comment: Athletes
type Athlete struct {
	AthleteID uint32      `max_len:"10"`  // athlete_id int(10) unsigned NOT NULL PRI  auto_increment "Athlete ID"
	Firstname null.String `max_len:"340"` // firstname varchar(340) NULL  DEFAULT 'NULL'  "First Name"
	Lastname  null.String `max_len:"340"` // lastname varchar(340) NULL  DEFAULT 'NULL'  "Last Name"
	Relations *athleteRelations
}

type athleteTeamRelations struct {
	parent   *AthleteTeam
	Athletes *Athletes // Reversed M:N athlete_team.team_id via athlete_team_member.team_id => athlete.athlete_id
}

func (e *AthleteTeam) setRelationParent() {
	if e.Relations != nil && e.Relations.parent == nil {
		e.Relations.parent = e
	}
}

func (e *AthleteTeam) NewRelations() *athleteTeamRelations {
	e.Relations = &athleteTeamRelations{parent: e}
	return e.Relations
}

// AthleteTeam represents a single row for DB table athlete_team. Auto generated.
// Table comment: Athlete Team
type AthleteTeam struct {
	TeamID    uint32 `max_len:"10"`  // team_id int(10) unsigned NOT NULL PRI  auto_increment ""
	Name      string `max_len:"340"` // name varchar(340) NOT NULL    "Team name"
	Relations *athleteTeamRelations
}

// AthleteTeamMember represents a single row for DB table athlete_team_member.
// Auto generated.
// Table comment: Athlete Team Members
type AthleteTeamMember struct {
	ID        uint32 // id int(12) unsigned NOT NULL PRI  auto_increment ""
	TeamID    uint32 // team_id int(10) unsigned NOT NULL MUL   "Athlete Team ID or AID"
	AthleteID uint32 // athlete_id int(10) unsigned NOT NULL MUL   "Athlete ID or AGID"
}

// CustomerAddressEntity represents a single row for DB table
// customer_address_entity. Auto generated.
// Table comment: Customer Address Entity
type CustomerAddressEntity struct {
	EntityID    uint32      // entity_id int(10) unsigned NOT NULL PRI  auto_increment "Entity ID"
	IncrementID null.String // increment_id varchar(50) NULL  DEFAULT 'NULL'  "Increment Id"
	ParentID    null.Uint32 // parent_id int(10) unsigned NULL MUL DEFAULT 'NULL'  "Parent ID"
	CreatedAt   time.Time   // created_at timestamp NOT NULL  DEFAULT 'current_timestamp()'  "Created At"
	UpdatedAt   time.Time   // updated_at timestamp NOT NULL  DEFAULT 'current_timestamp()' on update current_timestamp() "Updated At"
	IsActive    bool        // is_active smallint(5) unsigned NOT NULL  DEFAULT '1'  "Is Active"
	City        string      // city varchar(255) NOT NULL    "City"
	Company     null.String // company varchar(255) NULL  DEFAULT 'NULL'  "Company"
	CountryID   string      // country_id varchar(255) NOT NULL    "Country"
	Firstname   string      // firstname varchar(255) NOT NULL    "First Name"
	Lastname    string      // lastname varchar(255) NOT NULL    "Last Name"
	Postcode    null.String // postcode varchar(255) NULL  DEFAULT 'NULL'  "Zip/Postal Code"
	Region      null.String // region varchar(255) NULL  DEFAULT 'NULL'  "State/Province"
	Street      string      // street text NOT NULL    "Street Address"
}

type customerEntityRelations struct {
	parent                  *CustomerEntity
	Customeraddressentities *CustomerAddressEntities // Reversed 1:M customer_entity.entity_id => customer_address_entity.parent_id
}

func (e *CustomerEntity) setRelationParent() {
	if e.Relations != nil && e.Relations.parent == nil {
		e.Relations.parent = e
	}
}

func (e *CustomerEntity) NewRelations() *customerEntityRelations {
	e.Relations = &customerEntityRelations{parent: e}
	return e.Relations
}

// CustomerEntity represents a single row for DB table customer_entity. Auto
// generated.
// Table comment: Customer Entity
type CustomerEntity struct {
	EntityID         uint32      `max_len:"10"`  // entity_id int(10) unsigned NOT NULL PRI  auto_increment "Entity ID"
	WebsiteID        null.Uint16 `max_len:"5"`   // website_id smallint(5) unsigned NULL MUL DEFAULT 'NULL'  "Website ID"
	Email            null.String `max_len:"255"` // email varchar(255) NULL MUL DEFAULT 'NULL'  "Email"
	GroupID          uint16      `max_len:"5"`   // group_id smallint(5) unsigned NOT NULL  DEFAULT '0'  "Group ID"
	StoreID          null.Uint16 `max_len:"5"`   // store_id smallint(5) unsigned NULL MUL DEFAULT '0'  "Store ID"
	CreatedAt        time.Time   // created_at timestamp NOT NULL  DEFAULT 'current_timestamp()'  "Created At"
	UpdatedAt        time.Time   // updated_at timestamp NOT NULL  DEFAULT 'current_timestamp()' on update current_timestamp() "Updated At"
	IsActive         bool        `max_len:"5"`   // is_active smallint(5) unsigned NOT NULL  DEFAULT '1'  "Is Active"
	CreatedIn        null.String `max_len:"255"` // created_in varchar(255) NULL  DEFAULT 'NULL'  "Created From"
	Firstname        null.String `max_len:"255"` // firstname varchar(255) NULL MUL DEFAULT 'NULL'  "First Name"
	Lastname         null.String `max_len:"255"` // lastname varchar(255) NULL MUL DEFAULT 'NULL'  "Last Name"
	Dob              null.Time   // dob date NULL  DEFAULT 'NULL'  "Date of Birth"
	PasswordHash     null.String `max_len:"128"` // password_hash varchar(128) NULL  DEFAULT 'NULL'  "Password_hash"
	RpToken          null.String `max_len:"128"` // rp_token varchar(128) NULL  DEFAULT 'NULL'  "Reset password token"
	RpTokenCreatedAt null.Time   // rp_token_created_at datetime NULL  DEFAULT 'NULL'  "Reset password token creation time"
	DefaultBilling   null.Uint32 `max_len:"10"` // default_billing int(10) unsigned NULL  DEFAULT 'NULL'  "Default Billing Address"
	DefaultShipping  null.Uint32 `max_len:"10"` // default_shipping int(10) unsigned NULL  DEFAULT 'NULL'  "Default Shipping Address"
	Gender           null.Uint16 `max_len:"5"`  // gender smallint(5) unsigned NULL  DEFAULT 'NULL'  "Gender"
	Relations        *customerEntityRelations
}

// TableName constants define the names of all tables.
const (
	TableNameAthlete               = "athlete"
	TableNameAthleteTeam           = "athlete_team"
	TableNameAthleteTeamMember     = "athlete_team_member"
	TableNameCustomerAddressEntity = "customer_address_entity"
	TableNameCustomerEntity        = "customer_entity"
)

// Event functions are getting dispatched during before or after handling a
// collection or an entity.
// Context is always non-nil but either collection or entity pointer will be set.
type (
	EventAthleteFn               func(context.Context, *Athletes, *Athlete) error
	EventAthleteTeamFn           func(context.Context, *AthleteTeams, *AthleteTeam) error
	EventAthleteTeamMemberFn     func(context.Context, *AthleteTeamMembers, *AthleteTeamMember) error
	EventCustomerAddressEntityFn func(context.Context, *CustomerAddressEntities, *CustomerAddressEntity) error
	EventCustomerEntityFn        func(context.Context, *CustomerEntities, *CustomerEntity) error
)

// DBMOption provides various options to the DBM object.
type DBMOption struct {
	TableOptions                   []ddl.TableOption // gets applied at the beginning
	TableOptionsAfter              []ddl.TableOption // gets applied at the end
	eventAthleteFunc               [dml.EventFlagMax][]EventAthleteFn
	eventAthleteTeamFunc           [dml.EventFlagMax][]EventAthleteTeamFn
	eventAthleteTeamMemberFunc     [dml.EventFlagMax][]EventAthleteTeamMemberFn
	eventCustomerAddressEntityFunc [dml.EventFlagMax][]EventCustomerAddressEntityFn
	eventCustomerEntityFunc        [dml.EventFlagMax][]EventCustomerEntityFn
}

// AddEventAthlete adds a specific defined event call back to the DBM.
// It panics if the event argument is larger than dml.EventFlagMax.
func (o *DBMOption) AddEventAthlete(event dml.EventFlag, fn EventAthleteFn) *DBMOption {
	o.eventAthleteFunc[event] = append(o.eventAthleteFunc[event], fn)
	return o
}

// AddEventAthleteTeam adds a specific defined event call back to the DBM.
// It panics if the event argument is larger than dml.EventFlagMax.
func (o *DBMOption) AddEventAthleteTeam(event dml.EventFlag, fn EventAthleteTeamFn) *DBMOption {
	o.eventAthleteTeamFunc[event] = append(o.eventAthleteTeamFunc[event], fn)
	return o
}

// AddEventAthleteTeamMember adds a specific defined event call back to the DBM.
// It panics if the event argument is larger than dml.EventFlagMax.
func (o *DBMOption) AddEventAthleteTeamMember(event dml.EventFlag, fn EventAthleteTeamMemberFn) *DBMOption {
	o.eventAthleteTeamMemberFunc[event] = append(o.eventAthleteTeamMemberFunc[event], fn)
	return o
}

// AddEventCustomerAddressEntity adds a specific defined event call back to the
// DBM.
// It panics if the event argument is larger than dml.EventFlagMax.
func (o *DBMOption) AddEventCustomerAddressEntity(event dml.EventFlag, fn EventCustomerAddressEntityFn) *DBMOption {
	o.eventCustomerAddressEntityFunc[event] = append(o.eventCustomerAddressEntityFunc[event], fn)
	return o
}

// AddEventCustomerEntity adds a specific defined event call back to the DBM.
// It panics if the event argument is larger than dml.EventFlagMax.
func (o *DBMOption) AddEventCustomerEntity(event dml.EventFlag, fn EventCustomerEntityFn) *DBMOption {
	o.eventCustomerEntityFunc[event] = append(o.eventCustomerEntityFunc[event], fn)
	return o
}

// DBM defines the DataBaseManagement object for the tables  athlete,
// athlete_team, athlete_team_member, customer_address_entity, customer_entity
type DBM struct {
	*ddl.Tables
	option DBMOption
}

func (dbm DBM) eventAthleteFunc(ctx context.Context, ef dml.EventFlag, skipEvents bool, ec *Athletes, e *Athlete) error {
	if len(dbm.option.eventAthleteFunc[ef]) == 0 || skipEvents {
		return nil
	}
	for _, fn := range dbm.option.eventAthleteFunc[ef] {
		if err := fn(ctx, ec, e); err != nil {
			return errors.WithStack(err)
		}
	}
	return nil
}

func (dbm DBM) eventAthleteTeamFunc(ctx context.Context, ef dml.EventFlag, skipEvents bool, ec *AthleteTeams, e *AthleteTeam) error {
	if len(dbm.option.eventAthleteTeamFunc[ef]) == 0 || skipEvents {
		return nil
	}
	for _, fn := range dbm.option.eventAthleteTeamFunc[ef] {
		if err := fn(ctx, ec, e); err != nil {
			return errors.WithStack(err)
		}
	}
	return nil
}

func (dbm DBM) eventAthleteTeamMemberFunc(ctx context.Context, ef dml.EventFlag, skipEvents bool, ec *AthleteTeamMembers, e *AthleteTeamMember) error {
	if len(dbm.option.eventAthleteTeamMemberFunc[ef]) == 0 || skipEvents {
		return nil
	}
	for _, fn := range dbm.option.eventAthleteTeamMemberFunc[ef] {
		if err := fn(ctx, ec, e); err != nil {
			return errors.WithStack(err)
		}
	}
	return nil
}

func (dbm DBM) eventCustomerAddressEntityFunc(ctx context.Context, ef dml.EventFlag, skipEvents bool, ec *CustomerAddressEntities, e *CustomerAddressEntity) error {
	if len(dbm.option.eventCustomerAddressEntityFunc[ef]) == 0 || skipEvents {
		return nil
	}
	for _, fn := range dbm.option.eventCustomerAddressEntityFunc[ef] {
		if err := fn(ctx, ec, e); err != nil {
			return errors.WithStack(err)
		}
	}
	return nil
}

func (dbm DBM) eventCustomerEntityFunc(ctx context.Context, ef dml.EventFlag, skipEvents bool, ec *CustomerEntities, e *CustomerEntity) error {
	if len(dbm.option.eventCustomerEntityFunc[ef]) == 0 || skipEvents {
		return nil
	}
	for _, fn := range dbm.option.eventCustomerEntityFunc[ef] {
		if err := fn(ctx, ec, e); err != nil {
			return errors.WithStack(err)
		}
	}
	return nil
}

// NewDBManager returns a goified version of the MySQL/MariaDB table schema for
// the tables:  athlete, athlete_team, athlete_team_member,
// customer_address_entity, customer_entity Auto generated by dmlgen.
func NewDBManager(ctx context.Context, dbmo *DBMOption) (*DBM, error) {
	tbls, err := ddl.NewTables(append([]ddl.TableOption{ddl.WithCreateTable(ctx, TableNameAthlete, "", TableNameAthleteTeam, "", TableNameAthleteTeamMember, "", TableNameCustomerAddressEntity, "", TableNameCustomerEntity, "")}, dbmo.TableOptions...)...)
	if err != nil {
		return nil, errors.WithStack(err)
	}
	err = tbls.Options(
		ddl.WithQueryDBR(map[string]dml.QueryBuilder{
			// <FOREIGN_KEY_QUERIES athlete >
			"AthleteTeamMembersDeleteByFK": dbmo.InitDeleteFn(tbls.MustTable(TableNameAthleteTeamMember).Delete().Where(
				dml.Column(`athlete_id`).Equal().PlaceHolder(),
			)),
			"AthleteTeamMembersSelectByFK": dbmo.InitSelectFn(tbls.MustTable(TableNameAthleteTeamMember).Select("*").Where(
				dml.Column(`athlete_id`).Equal().PlaceHolder(),
			)),
			"AthleteTeamsDeleteByFK": dbmo.InitDeleteFn(tbls.MustTable(TableNameAthleteTeamMember).Delete().Where(
				dml.Column(`athlete_id`).Equal().PlaceHolder(),
			)),
			"AthleteTeamsSelectByFK": dbmo.InitSelectFn(tbls.MustTable(TableNameAthleteTeamMember).Select("*").Where(
				dml.Column(`athlete_id`).Equal().PlaceHolder(),
			)),
			// </FOREIGN_KEY_QUERIES athlete >
			// <FOREIGN_KEY_QUERIES athlete_team >
			"AthletesDeleteByFK": dbmo.InitDeleteFn(tbls.MustTable(TableNameAthleteTeamMember).Delete().Where(
				dml.Column(`team_id`).Equal().PlaceHolder(),
			)),
			"AthletesSelectByFK": dbmo.InitSelectFn(tbls.MustTable(TableNameAthleteTeamMember).Select("*").Where(
				dml.Column(`team_id`).Equal().PlaceHolder(),
			)),
			// </FOREIGN_KEY_QUERIES athlete_team >
			// <FOREIGN_KEY_QUERIES customer_entity >
			"CustomeraddressentitiesDeleteByFK": dbmo.InitDeleteFn(tbls.MustTable(TableNameCustomerAddressEntity).Delete().Where(
				dml.Column(`parent_id`).Equal().PlaceHolder(),
			)),
			"CustomeraddressentitiesSelectByFK": dbmo.InitSelectFn(tbls.MustTable(TableNameCustomerAddressEntity).Select("*").Where(
				dml.Column(`parent_id`).Equal().PlaceHolder(),
			)),
			// </FOREIGN_KEY_QUERIES customer_entity >
		}),
	)
	if err != nil {
		return nil, err
	}
	if err := tbls.Options(dbmo.TableOptionsAfter...); err != nil {
		return nil, err
	}
	return &DBM{Tables: tbls, option: *dbmo}, nil
}

func (r *athleteRelations) DeleteAthleteTeamMembers(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) error {
	dbr := dbm.ConnPool.WithCacheKey("AthleteTeamMembersDeleteByFK", opts...)
	res, err := dbr.ExecContext(ctx, r.parent.AthleteID)
	err = dbr.ResultCheckFn(TableNameAthleteTeamMember, len(r.AthleteTeamMembers.Data), res, err)
	if err == nil && r.AthleteTeamMembers != nil {
		r.AthleteTeamMembers.Clear()
	}
	return errors.WithStack(err)
}

func (r *athleteRelations) InsertAthleteTeamMembers(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) error {
	if r.AthleteTeamMembers == nil || len(r.AthleteTeamMembers.Data) == 0 {
		return nil
	}
	for _, e2 := range r.AthleteTeamMembers.Data {
		e2.AthleteID = r.parent.AthleteID
	}
	return errors.WithStack(r.AthleteTeamMembers.DBInsert(ctx, dbm, opts...))
}

func (r *customerEntityRelations) UpdateAthleteTeamMembers(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (err error) {
	if r.AthleteTeamMembers == nil || len(r.AthleteTeamMembers.Data) == 0 {
		dbr := dbm.ConnPool.WithCacheKey("AthleteTeamMembersDeleteByFK", opts...)
		res, err := dbr.ExecContext(ctx, r.parent.AthleteID)
		return dbr.ResultCheckFn(TableNameAthleteTeamMember, -1, res, errors.WithStack(err))
	}
	for _, e2 := range r.AthleteTeamMembers.Data {
		e2.AthleteID = r.parent.AthleteID
	}
	err = r.AthleteTeamMembers.DBUpdate(ctx, dbm, opts...)
	return errors.WithStack(err)
}

func (r *athleteRelations) LoadAthleteTeamMembers(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (rowCount uint64, err error) {
	if r.AthleteTeamMembers == nil {
		r.AthleteTeamMembers = &AthleteTeamMembers{}
	}
	r.AthleteTeamMembers.Clear()
	rowCount, err = dbm.ConnPool.WithCacheKey("AthleteTeamMembersSelectByFK", opts...).Load(ctx, r.AthleteTeamMembers, r.parent.EntityID)
	return rowCount, errors.WithStack(err)
}

func (r *athleteRelations) DeleteAthleteTeams(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) error {
	dbr := dbm.ConnPool.WithCacheKey("AthleteTeamsDeleteByFK", opts...)
	res, err := dbr.ExecContext(ctx, r.parent.AthleteID)
	err = dbr.ResultCheckFn(TableNameAthleteTeamMember, len(r.AthleteTeams.Data), res, err)
	if err == nil && r.AthleteTeams != nil {
		r.AthleteTeams.Clear()
	}
	return errors.WithStack(err)
}

func (r *athleteRelations) InsertAthleteTeams(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) error {
	if r.AthleteTeams == nil || len(r.AthleteTeams.Data) == 0 {
		return nil
	}
	for _, e2 := range r.AthleteTeams.Data {
		e2.AthleteID = r.parent.AthleteID
	}
	return errors.WithStack(r.AthleteTeams.DBInsert(ctx, dbm, opts...))
}

func (r *customerEntityRelations) UpdateAthleteTeams(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (err error) {
	if r.AthleteTeams == nil || len(r.AthleteTeams.Data) == 0 {
		dbr := dbm.ConnPool.WithCacheKey("AthleteTeamsDeleteByFK", opts...)
		res, err := dbr.ExecContext(ctx, r.parent.AthleteID)
		return dbr.ResultCheckFn(TableNameAthleteTeamMember, -1, res, errors.WithStack(err))
	}
	for _, e2 := range r.AthleteTeams.Data {
		e2.AthleteID = r.parent.AthleteID
	}
	err = r.AthleteTeams.DBUpdate(ctx, dbm, opts...)
	return errors.WithStack(err)
}

func (r *athleteRelations) LoadAthleteTeams(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (rowCount uint64, err error) {
	if r.AthleteTeams == nil {
		r.AthleteTeams = &AthleteTeams{}
	}
	r.AthleteTeams.Clear()
	rowCount, err = dbm.ConnPool.WithCacheKey("AthleteTeamsSelectByFK", opts...).Load(ctx, r.AthleteTeams, r.parent.EntityID)
	return rowCount, errors.WithStack(err)
}

func (r *athleteRelations) InsertAll(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) error {
	if err := r.InsertAthleteTeamMembers(ctx, dbm, opts...); err != nil {
		return errors.WithStack(err)
	}
	if err := r.InsertAthleteTeams(ctx, dbm, opts...); err != nil {
		return errors.WithStack(err)
	}
	return nil
}

func (r *athleteRelations) LoadAll(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (err error) {
	if _, err = r.LoadAthleteTeamMembers(ctx, dbm, opts...); err != nil {
		return errors.WithStack(err)
	}
	if _, err = r.LoadAthleteTeams(ctx, dbm, opts...); err != nil {
		return errors.WithStack(err)
	}
	return nil
}

func (r *athleteRelations) UpdateAll(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) error {
	if err := r.UpdateAthleteTeamMembers(ctx, dbm, opts...); err != nil {
		return errors.WithStack(err)
	}
	if err := r.UpdateAthleteTeams(ctx, dbm, opts...); err != nil {
		return errors.WithStack(err)
	}
	return nil
}

func (r *athleteRelations) DeleteAll(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) error {
	if err := r.DeleteAthleteTeamMembers(ctx, dbm, opts...); err != nil {
		return errors.WithStack(err)
	}
	if err := r.DeleteAthleteTeams(ctx, dbm, opts...); err != nil {
		return errors.WithStack(err)
	}
	return nil
}

// AssignLastInsertID updates the increment ID field with the last inserted ID
// from an INSERT operation. Implements dml.InsertIDAssigner. Auto generated.
func (e *Athlete) AssignLastInsertID(id int64) {
	e.AthleteID = uint32(id)
}

// MapColumns implements interface ColumnMapper only partially. Auto generated.
func (e *Athlete) MapColumns(cm *dml.ColumnMap) error {
	for cm.Next(3) {
		switch c := cm.Column(); c {
		case "athlete_id", "0":
			cm.Uint32(&e.AthleteID)
		case "firstname", "1":
			cm.NullString(&e.Firstname)
		case "lastname", "2":
			cm.NullString(&e.Lastname)
		default:
			return errors.NotFound.Newf("[dmltestgeneratedMToM] Athlete Column %q not found", c)
		}
	}
	return errors.WithStack(cm.Err())
}

// IsSet returns true if the entity has non-empty primary keys.
func (e *Athlete) IsSet() bool { return e.AthleteID > 0 }

// Athletes represents a collection type for DB table athlete
// Not thread safe. Auto generated.
type Athletes struct {
	Data []*Athlete `json:"data,omitempty"`
}

// NewAthletes  creates a new initialized collection. Auto generated.
func NewAthletes() *Athletes {
	return &Athletes{
		Data: make([]*Athlete, 0, 5),
	}
}

// AssignLastInsertID traverses through the slice and sets an incrementing new ID
// to each entity.
func (cc *Athletes) AssignLastInsertID(id int64) {
	for i := 0; i < len(cc.Data); i++ {
		cc.Data[i].AssignLastInsertID(id + int64(i))
	}
}

func (cc *Athletes) scanColumns(cm *dml.ColumnMap, e *Athlete) error {
	if err := e.MapColumns(cm); err != nil {
		return errors.WithStack(err)
	}
	// this function might get extended.
	return nil
}

// MapColumns implements dml.ColumnMapper interface. Auto generated.
func (cc *Athletes) MapColumns(cm *dml.ColumnMap) error {
	switch m := cm.Mode(); m {
	case dml.ColumnMapEntityReadAll, dml.ColumnMapEntityReadSet:
		for _, e := range cc.Data {
			if err := cc.scanColumns(cm, e); err != nil {
				return errors.WithStack(err)
			}
		}
	case dml.ColumnMapScan:
		if cm.Count == 0 {
			cc.Clear()
		}
		var e Athlete
		if err := cc.scanColumns(cm, &e); err != nil {
			return errors.WithStack(err)
		}
		cc.Data = append(cc.Data, &e)
	case dml.ColumnMapCollectionReadSet:
		for cm.Next(0) {
			switch c := cm.Column(); c {
			case "athlete_id":
				cm = cm.Uint32s(cc.AthleteIDs()...)
			default:
				return errors.NotFound.Newf("[dmltestgeneratedMToM] Athletes Column %q not found", c)
			}
		} // end for cm.Next
	default:
		return errors.NotSupported.Newf("[dmltestgeneratedMToM] Unknown Mode: %q", string(m))
	}
	return cm.Err()
}

// AthleteIDs returns a slice with the data or appends it to a slice.
// Auto generated.
func (cc *Athletes) AthleteIDs(ret ...uint32) []uint32 {
	if cc == nil {
		return nil
	}
	if ret == nil {
		ret = make([]uint32, 0, len(cc.Data))
	}
	for _, e := range cc.Data {
		ret = append(ret, e.AthleteID)
	}
	return ret
}

func (r *athleteTeamRelations) DeleteAthletes(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) error {
	dbr := dbm.ConnPool.WithCacheKey("AthletesDeleteByFK", opts...)
	res, err := dbr.ExecContext(ctx, r.parent.TeamID)
	err = dbr.ResultCheckFn(TableNameAthleteTeamMember, len(r.Athletes.Data), res, err)
	if err == nil && r.Athletes != nil {
		r.Athletes.Clear()
	}
	return errors.WithStack(err)
}

func (r *athleteTeamRelations) InsertAthletes(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) error {
	if r.Athletes == nil || len(r.Athletes.Data) == 0 {
		return nil
	}
	for _, e2 := range r.Athletes.Data {
		e2.TeamID = r.parent.TeamID
	}
	return errors.WithStack(r.Athletes.DBInsert(ctx, dbm, opts...))
}

func (r *customerEntityRelations) UpdateAthletes(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (err error) {
	if r.Athletes == nil || len(r.Athletes.Data) == 0 {
		dbr := dbm.ConnPool.WithCacheKey("AthletesDeleteByFK", opts...)
		res, err := dbr.ExecContext(ctx, r.parent.TeamID)
		return dbr.ResultCheckFn(TableNameAthleteTeamMember, -1, res, errors.WithStack(err))
	}
	for _, e2 := range r.Athletes.Data {
		e2.TeamID = r.parent.TeamID
	}
	err = r.Athletes.DBUpdate(ctx, dbm, opts...)
	return errors.WithStack(err)
}

func (r *athleteTeamRelations) LoadAthletes(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (rowCount uint64, err error) {
	if r.Athletes == nil {
		r.Athletes = &Athletes{}
	}
	r.Athletes.Clear()
	rowCount, err = dbm.ConnPool.WithCacheKey("AthletesSelectByFK", opts...).Load(ctx, r.Athletes, r.parent.EntityID)
	return rowCount, errors.WithStack(err)
}

func (r *athleteTeamRelations) InsertAll(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) error {
	if err := r.InsertAthletes(ctx, dbm, opts...); err != nil {
		return errors.WithStack(err)
	}
	return nil
}

func (r *athleteTeamRelations) LoadAll(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (err error) {
	if _, err = r.LoadAthletes(ctx, dbm, opts...); err != nil {
		return errors.WithStack(err)
	}
	return nil
}

func (r *athleteTeamRelations) UpdateAll(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) error {
	if err := r.UpdateAthletes(ctx, dbm, opts...); err != nil {
		return errors.WithStack(err)
	}
	return nil
}

func (r *athleteTeamRelations) DeleteAll(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) error {
	if err := r.DeleteAthletes(ctx, dbm, opts...); err != nil {
		return errors.WithStack(err)
	}
	return nil
}

// AssignLastInsertID updates the increment ID field with the last inserted ID
// from an INSERT operation. Implements dml.InsertIDAssigner. Auto generated.
func (e *AthleteTeam) AssignLastInsertID(id int64) {
	e.TeamID = uint32(id)
}

// MapColumns implements interface ColumnMapper only partially. Auto generated.
func (e *AthleteTeam) MapColumns(cm *dml.ColumnMap) error {
	for cm.Next(2) {
		switch c := cm.Column(); c {
		case "team_id", "0":
			cm.Uint32(&e.TeamID)
		case "name", "1":
			cm.String(&e.Name)
		default:
			return errors.NotFound.Newf("[dmltestgeneratedMToM] AthleteTeam Column %q not found", c)
		}
	}
	return errors.WithStack(cm.Err())
}

// IsSet returns true if the entity has non-empty primary keys.
func (e *AthleteTeam) IsSet() bool { return e.TeamID > 0 }

// AthleteTeams represents a collection type for DB table athlete_team
// Not thread safe. Auto generated.
type AthleteTeams struct {
	Data []*AthleteTeam `json:"data,omitempty"`
}

// NewAthleteTeams  creates a new initialized collection. Auto generated.
func NewAthleteTeams() *AthleteTeams {
	return &AthleteTeams{
		Data: make([]*AthleteTeam, 0, 5),
	}
}

// AssignLastInsertID traverses through the slice and sets an incrementing new ID
// to each entity.
func (cc *AthleteTeams) AssignLastInsertID(id int64) {
	for i := 0; i < len(cc.Data); i++ {
		cc.Data[i].AssignLastInsertID(id + int64(i))
	}
}

func (cc *AthleteTeams) scanColumns(cm *dml.ColumnMap, e *AthleteTeam) error {
	if err := e.MapColumns(cm); err != nil {
		return errors.WithStack(err)
	}
	// this function might get extended.
	return nil
}

// MapColumns implements dml.ColumnMapper interface. Auto generated.
func (cc *AthleteTeams) MapColumns(cm *dml.ColumnMap) error {
	switch m := cm.Mode(); m {
	case dml.ColumnMapEntityReadAll, dml.ColumnMapEntityReadSet:
		for _, e := range cc.Data {
			if err := cc.scanColumns(cm, e); err != nil {
				return errors.WithStack(err)
			}
		}
	case dml.ColumnMapScan:
		if cm.Count == 0 {
			cc.Clear()
		}
		var e AthleteTeam
		if err := cc.scanColumns(cm, &e); err != nil {
			return errors.WithStack(err)
		}
		cc.Data = append(cc.Data, &e)
	case dml.ColumnMapCollectionReadSet:
		for cm.Next(0) {
			switch c := cm.Column(); c {
			case "team_id":
				cm = cm.Uint32s(cc.TeamIDs()...)
			default:
				return errors.NotFound.Newf("[dmltestgeneratedMToM] AthleteTeams Column %q not found", c)
			}
		} // end for cm.Next
	default:
		return errors.NotSupported.Newf("[dmltestgeneratedMToM] Unknown Mode: %q", string(m))
	}
	return cm.Err()
}

// TeamIDs returns a slice with the data or appends it to a slice.
// Auto generated.
func (cc *AthleteTeams) TeamIDs(ret ...uint32) []uint32 {
	if cc == nil {
		return nil
	}
	if ret == nil {
		ret = make([]uint32, 0, len(cc.Data))
	}
	for _, e := range cc.Data {
		ret = append(ret, e.TeamID)
	}
	return ret
}

// AssignLastInsertID updates the increment ID field with the last inserted ID
// from an INSERT operation. Implements dml.InsertIDAssigner. Auto generated.
func (e *AthleteTeamMember) AssignLastInsertID(id int64) {
	e.ID = uint32(id)
}

// MapColumns implements interface ColumnMapper only partially. Auto generated.
func (e *AthleteTeamMember) MapColumns(cm *dml.ColumnMap) error {
	for cm.Next(3) {
		switch c := cm.Column(); c {
		case "id", "0":
			cm.Uint32(&e.ID)
		case "team_id", "1":
			cm.Uint32(&e.TeamID)
		case "athlete_id", "2":
			cm.Uint32(&e.AthleteID)
		default:
			return errors.NotFound.Newf("[dmltestgeneratedMToM] AthleteTeamMember Column %q not found", c)
		}
	}
	return errors.WithStack(cm.Err())
}

// IsSet returns true if the entity has non-empty primary keys.
func (e *AthleteTeamMember) IsSet() bool { return e.ID > 0 }

// AthleteTeamMembers represents a collection type for DB table
// athlete_team_member
// Not thread safe. Auto generated.
type AthleteTeamMembers struct {
	Data []*AthleteTeamMember `json:"data,omitempty"`
}

// NewAthleteTeamMembers  creates a new initialized collection. Auto generated.
func NewAthleteTeamMembers() *AthleteTeamMembers {
	return &AthleteTeamMembers{
		Data: make([]*AthleteTeamMember, 0, 5),
	}
}

// AssignLastInsertID traverses through the slice and sets an incrementing new ID
// to each entity.
func (cc *AthleteTeamMembers) AssignLastInsertID(id int64) {
	for i := 0; i < len(cc.Data); i++ {
		cc.Data[i].AssignLastInsertID(id + int64(i))
	}
}

func (cc *AthleteTeamMembers) scanColumns(cm *dml.ColumnMap, e *AthleteTeamMember) error {
	if err := e.MapColumns(cm); err != nil {
		return errors.WithStack(err)
	}
	// this function might get extended.
	return nil
}

// MapColumns implements dml.ColumnMapper interface. Auto generated.
func (cc *AthleteTeamMembers) MapColumns(cm *dml.ColumnMap) error {
	switch m := cm.Mode(); m {
	case dml.ColumnMapEntityReadAll, dml.ColumnMapEntityReadSet:
		for _, e := range cc.Data {
			if err := cc.scanColumns(cm, e); err != nil {
				return errors.WithStack(err)
			}
		}
	case dml.ColumnMapScan:
		if cm.Count == 0 {
			cc.Clear()
		}
		var e AthleteTeamMember
		if err := cc.scanColumns(cm, &e); err != nil {
			return errors.WithStack(err)
		}
		cc.Data = append(cc.Data, &e)
	case dml.ColumnMapCollectionReadSet:
		for cm.Next(0) {
			switch c := cm.Column(); c {
			case "id":
				cm = cm.Uint32s(cc.IDs()...)
			default:
				return errors.NotFound.Newf("[dmltestgeneratedMToM] AthleteTeamMembers Column %q not found", c)
			}
		} // end for cm.Next
	default:
		return errors.NotSupported.Newf("[dmltestgeneratedMToM] Unknown Mode: %q", string(m))
	}
	return cm.Err()
}

// IDs returns a slice with the data or appends it to a slice.
// Auto generated.
func (cc *AthleteTeamMembers) IDs(ret ...uint32) []uint32 {
	if cc == nil {
		return nil
	}
	if ret == nil {
		ret = make([]uint32, 0, len(cc.Data))
	}
	for _, e := range cc.Data {
		ret = append(ret, e.ID)
	}
	return ret
}

// AssignLastInsertID updates the increment ID field with the last inserted ID
// from an INSERT operation. Implements dml.InsertIDAssigner. Auto generated.
func (e *CustomerAddressEntity) AssignLastInsertID(id int64) {
	e.EntityID = uint32(id)
}

// MapColumns implements interface ColumnMapper only partially. Auto generated.
func (e *CustomerAddressEntity) MapColumns(cm *dml.ColumnMap) error {
	for cm.Next(14) {
		switch c := cm.Column(); c {
		case "entity_id", "0":
			cm.Uint32(&e.EntityID)
		case "increment_id", "1":
			cm.NullString(&e.IncrementID)
		case "parent_id", "2":
			cm.NullUint32(&e.ParentID)
		case "created_at", "3":
			cm.Time(&e.CreatedAt)
		case "updated_at", "4":
			cm.Time(&e.UpdatedAt)
		case "is_active", "5":
			cm.Bool(&e.IsActive)
		case "city", "6":
			cm.String(&e.City)
		case "company", "7":
			cm.NullString(&e.Company)
		case "country_id", "8":
			cm.String(&e.CountryID)
		case "firstname", "9":
			cm.String(&e.Firstname)
		case "lastname", "10":
			cm.String(&e.Lastname)
		case "postcode", "11":
			cm.NullString(&e.Postcode)
		case "region", "12":
			cm.NullString(&e.Region)
		case "street", "13":
			cm.String(&e.Street)
		default:
			return errors.NotFound.Newf("[dmltestgeneratedMToM] CustomerAddressEntity Column %q not found", c)
		}
	}
	return errors.WithStack(cm.Err())
}

// IsSet returns true if the entity has non-empty primary keys.
func (e *CustomerAddressEntity) IsSet() bool { return e.EntityID > 0 }

// CustomerAddressEntities represents a collection type for DB table
// customer_address_entity
// Not thread safe. Auto generated.
type CustomerAddressEntities struct {
	Data []*CustomerAddressEntity `json:"data,omitempty"`
}

// NewCustomerAddressEntities  creates a new initialized collection. Auto
// generated.
func NewCustomerAddressEntities() *CustomerAddressEntities {
	return &CustomerAddressEntities{
		Data: make([]*CustomerAddressEntity, 0, 5),
	}
}

// AssignLastInsertID traverses through the slice and sets an incrementing new ID
// to each entity.
func (cc *CustomerAddressEntities) AssignLastInsertID(id int64) {
	for i := 0; i < len(cc.Data); i++ {
		cc.Data[i].AssignLastInsertID(id + int64(i))
	}
}

func (cc *CustomerAddressEntities) scanColumns(cm *dml.ColumnMap, e *CustomerAddressEntity) error {
	if err := e.MapColumns(cm); err != nil {
		return errors.WithStack(err)
	}
	// this function might get extended.
	return nil
}

// MapColumns implements dml.ColumnMapper interface. Auto generated.
func (cc *CustomerAddressEntities) MapColumns(cm *dml.ColumnMap) error {
	switch m := cm.Mode(); m {
	case dml.ColumnMapEntityReadAll, dml.ColumnMapEntityReadSet:
		for _, e := range cc.Data {
			if err := cc.scanColumns(cm, e); err != nil {
				return errors.WithStack(err)
			}
		}
	case dml.ColumnMapScan:
		if cm.Count == 0 {
			cc.Clear()
		}
		var e CustomerAddressEntity
		if err := cc.scanColumns(cm, &e); err != nil {
			return errors.WithStack(err)
		}
		cc.Data = append(cc.Data, &e)
	case dml.ColumnMapCollectionReadSet:
		for cm.Next(0) {
			switch c := cm.Column(); c {
			case "entity_id":
				cm = cm.Uint32s(cc.EntityIDs()...)
			default:
				return errors.NotFound.Newf("[dmltestgeneratedMToM] CustomerAddressEntities Column %q not found", c)
			}
		} // end for cm.Next
	default:
		return errors.NotSupported.Newf("[dmltestgeneratedMToM] Unknown Mode: %q", string(m))
	}
	return cm.Err()
}

// EntityIDs returns a slice with the data or appends it to a slice.
// Auto generated.
func (cc *CustomerAddressEntities) EntityIDs(ret ...uint32) []uint32 {
	if cc == nil {
		return nil
	}
	if ret == nil {
		ret = make([]uint32, 0, len(cc.Data))
	}
	for _, e := range cc.Data {
		ret = append(ret, e.EntityID)
	}
	return ret
}

func (r *customerEntityRelations) DeleteCustomeraddressentities(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) error {
	dbr := dbm.ConnPool.WithCacheKey("CustomeraddressentitiesDeleteByFK", opts...)
	res, err := dbr.ExecContext(ctx, r.parent.EntityID)
	err = dbr.ResultCheckFn(TableNameCustomerAddressEntity, len(r.Customeraddressentities.Data), res, err)
	if err == nil && r.Customeraddressentities != nil {
		r.Customeraddressentities.Clear()
	}
	return errors.WithStack(err)
}

func (r *customerEntityRelations) InsertCustomeraddressentities(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) error {
	if r.Customeraddressentities == nil || len(r.Customeraddressentities.Data) == 0 {
		return nil
	}
	for _, e2 := range r.Customeraddressentities.Data {
		e2.ParentID = null.MakeUint32(uint32(r.parent.EntityID))
	}
	return errors.WithStack(r.Customeraddressentities.DBInsert(ctx, dbm, opts...))
}

func (r *customerEntityRelations) UpdateCustomeraddressentities(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (err error) {
	if r.Customeraddressentities == nil || len(r.Customeraddressentities.Data) == 0 {
		dbr := dbm.ConnPool.WithCacheKey("CustomeraddressentitiesDeleteByFK", opts...)
		res, err := dbr.ExecContext(ctx, r.parent.EntityID)
		return dbr.ResultCheckFn(TableNameCustomerAddressEntity, -1, res, errors.WithStack(err))
	}
	for _, e2 := range r.Customeraddressentities.Data {
		e2.ParentID = null.MakeUint32(uint32(r.parent.EntityID))
	}
	err = r.Customeraddressentities.DBUpdate(ctx, dbm, opts...)
	return errors.WithStack(err)
}

func (r *customerEntityRelations) LoadCustomeraddressentities(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (rowCount uint64, err error) {
	if r.Customeraddressentities == nil {
		r.Customeraddressentities = &Customeraddressentities{}
	}
	r.Customeraddressentities.Clear()
	rowCount, err = dbm.ConnPool.WithCacheKey("CustomeraddressentitiesSelectByFK", opts...).Load(ctx, r.Customeraddressentities, r.parent.EntityID)
	return rowCount, errors.WithStack(err)
}

func (r *customerEntityRelations) InsertAll(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) error {
	if err := r.InsertCustomeraddressentities(ctx, dbm, opts...); err != nil {
		return errors.WithStack(err)
	}
	return nil
}

func (r *customerEntityRelations) LoadAll(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) (err error) {
	if _, err = r.LoadCustomeraddressentities(ctx, dbm, opts...); err != nil {
		return errors.WithStack(err)
	}
	return nil
}

func (r *customerEntityRelations) UpdateAll(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) error {
	if err := r.UpdateCustomeraddressentities(ctx, dbm, opts...); err != nil {
		return errors.WithStack(err)
	}
	return nil
}

func (r *customerEntityRelations) DeleteAll(ctx context.Context, dbm *DBM, opts ...dml.DBRFunc) error {
	if err := r.DeleteCustomeraddressentities(ctx, dbm, opts...); err != nil {
		return errors.WithStack(err)
	}
	return nil
}

// AssignLastInsertID updates the increment ID field with the last inserted ID
// from an INSERT operation. Implements dml.InsertIDAssigner. Auto generated.
func (e *CustomerEntity) AssignLastInsertID(id int64) {
	e.EntityID = uint32(id)
}

// MapColumns implements interface ColumnMapper only partially. Auto generated.
func (e *CustomerEntity) MapColumns(cm *dml.ColumnMap) error {
	for cm.Next(18) {
		switch c := cm.Column(); c {
		case "entity_id", "0":
			cm.Uint32(&e.EntityID)
		case "website_id", "1":
			cm.NullUint16(&e.WebsiteID)
		case "email", "2":
			cm.NullString(&e.Email)
		case "group_id", "3":
			cm.Uint16(&e.GroupID)
		case "store_id", "4":
			cm.NullUint16(&e.StoreID)
		case "created_at", "5":
			cm.Time(&e.CreatedAt)
		case "updated_at", "6":
			cm.Time(&e.UpdatedAt)
		case "is_active", "7":
			cm.Bool(&e.IsActive)
		case "created_in", "8":
			cm.NullString(&e.CreatedIn)
		case "firstname", "9":
			cm.NullString(&e.Firstname)
		case "lastname", "10":
			cm.NullString(&e.Lastname)
		case "dob", "11":
			cm.NullTime(&e.Dob)
		case "password_hash", "12":
			cm.NullString(&e.PasswordHash)
		case "rp_token", "13":
			cm.NullString(&e.RpToken)
		case "rp_token_created_at", "14":
			cm.NullTime(&e.RpTokenCreatedAt)
		case "default_billing", "15":
			cm.NullUint32(&e.DefaultBilling)
		case "default_shipping", "16":
			cm.NullUint32(&e.DefaultShipping)
		case "gender", "17":
			cm.NullUint16(&e.Gender)
		default:
			return errors.NotFound.Newf("[dmltestgeneratedMToM] CustomerEntity Column %q not found", c)
		}
	}
	return errors.WithStack(cm.Err())
}

// IsSet returns true if the entity has non-empty primary keys.
func (e *CustomerEntity) IsSet() bool { return e.EntityID > 0 }

// CustomerEntities represents a collection type for DB table customer_entity
// Not thread safe. Auto generated.
type CustomerEntities struct {
	Data []*CustomerEntity `json:"data,omitempty"`
}

// NewCustomerEntities  creates a new initialized collection. Auto generated.
func NewCustomerEntities() *CustomerEntities {
	return &CustomerEntities{
		Data: make([]*CustomerEntity, 0, 5),
	}
}

// AssignLastInsertID traverses through the slice and sets an incrementing new ID
// to each entity.
func (cc *CustomerEntities) AssignLastInsertID(id int64) {
	for i := 0; i < len(cc.Data); i++ {
		cc.Data[i].AssignLastInsertID(id + int64(i))
	}
}

func (cc *CustomerEntities) scanColumns(cm *dml.ColumnMap, e *CustomerEntity) error {
	if err := e.MapColumns(cm); err != nil {
		return errors.WithStack(err)
	}
	// this function might get extended.
	return nil
}

// MapColumns implements dml.ColumnMapper interface. Auto generated.
func (cc *CustomerEntities) MapColumns(cm *dml.ColumnMap) error {
	switch m := cm.Mode(); m {
	case dml.ColumnMapEntityReadAll, dml.ColumnMapEntityReadSet:
		for _, e := range cc.Data {
			if err := cc.scanColumns(cm, e); err != nil {
				return errors.WithStack(err)
			}
		}
	case dml.ColumnMapScan:
		if cm.Count == 0 {
			cc.Clear()
		}
		var e CustomerEntity
		if err := cc.scanColumns(cm, &e); err != nil {
			return errors.WithStack(err)
		}
		cc.Data = append(cc.Data, &e)
	case dml.ColumnMapCollectionReadSet:
		for cm.Next(0) {
			switch c := cm.Column(); c {
			case "entity_id":
				cm = cm.Uint32s(cc.EntityIDs()...)
			default:
				return errors.NotFound.Newf("[dmltestgeneratedMToM] CustomerEntities Column %q not found", c)
			}
		} // end for cm.Next
	default:
		return errors.NotSupported.Newf("[dmltestgeneratedMToM] Unknown Mode: %q", string(m))
	}
	return cm.Err()
}

// EntityIDs returns a slice with the data or appends it to a slice.
// Auto generated.
func (cc *CustomerEntities) EntityIDs(ret ...uint32) []uint32 {
	if cc == nil {
		return nil
	}
	if ret == nil {
		ret = make([]uint32, 0, len(cc.Data))
	}
	for _, e := range cc.Data {
		ret = append(ret, e.EntityID)
	}
	return ret
}
